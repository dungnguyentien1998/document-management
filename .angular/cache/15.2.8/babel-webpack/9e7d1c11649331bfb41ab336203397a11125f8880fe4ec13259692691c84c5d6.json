{"ast":null,"code":"import deepmerge from 'deepmerge';\n\n// Cannot import from the @ngrx/store package due to a module resolution issue.\n// See Issue #206.\nconst INIT_ACTION = '@ngrx/store/init';\nconst UPDATE_ACTION = '@ngrx/store/update-reducers';\nconst detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n// correctly parse dates from local storage\nconst dateReviver = (_key, value) => {\n  if (typeof value === 'string' && detectDate.test(value)) {\n    return new Date(value);\n  }\n  return value;\n};\nconst dummyReviver = (_key, value) => value;\nconst checkIsBrowserEnv = () => {\n  return typeof window !== 'undefined';\n};\nconst validateStateKeys = keys => {\n  return keys.map(key => {\n    let attr = key;\n    if (typeof key === 'object') {\n      attr = Object.keys(key)[0];\n    }\n    if (typeof attr !== 'string') {\n      throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);\n    }\n    return key;\n  });\n};\nconst rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {\n  return keys.reduce((acc, curr) => {\n    let key = curr;\n    let reviver = restoreDates ? dateReviver : dummyReviver;\n    let deserialize;\n    let decrypt;\n    if (typeof key === 'object') {\n      key = Object.keys(key)[0];\n      // use the custom reviver function\n      if (typeof curr[key] === 'function') {\n        reviver = curr[key];\n      } else {\n        // use custom reviver function if available\n        if (curr[key].reviver) {\n          reviver = curr[key].reviver;\n        }\n        // use custom serialize function if available\n        if (curr[key].deserialize) {\n          deserialize = curr[key].deserialize;\n        }\n      }\n      // Ensure that encrypt and decrypt functions are both present\n      if (curr[key].encrypt && curr[key].decrypt) {\n        if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n          decrypt = curr[key].decrypt;\n        } else {\n          console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);\n        }\n      } else if (curr[key].encrypt || curr[key].decrypt) {\n        // Let know that one of the encryption functions is not provided\n        console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);\n      }\n    }\n    if (storage !== undefined) {\n      let stateSlice = storage.getItem(storageKeySerializer(key));\n      if (stateSlice) {\n        // Use provided decrypt function\n        if (decrypt) {\n          stateSlice = decrypt(stateSlice);\n        }\n        const isObjectRegex = new RegExp('{|\\\\[');\n        let raw = stateSlice;\n        if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n          raw = JSON.parse(stateSlice, reviver);\n        }\n        return Object.assign({}, acc, {\n          [key]: deserialize ? deserialize(raw) : raw\n        });\n      }\n    }\n    return acc;\n  }, {});\n};\n// Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\nfunction createStateSlice(existingSlice, filter) {\n  return filter.reduce((memo, attr) => {\n    if (typeof attr === 'string' || typeof attr === 'number') {\n      const value = existingSlice?.[attr];\n      if (value !== undefined) {\n        memo[attr] = value;\n      }\n    } else {\n      for (const key in attr) {\n        if (Object.prototype.hasOwnProperty.call(attr, key)) {\n          const element = attr[key];\n          memo[key] = createStateSlice(existingSlice[key], element);\n        }\n      }\n    }\n    return memo;\n  }, {});\n}\nconst syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {\n  if (syncCondition) {\n    try {\n      if (syncCondition(state) !== true) {\n        return;\n      }\n    } catch (e) {\n      // Treat TypeError as do not sync\n      if (e instanceof TypeError) {\n        return;\n      }\n      throw e;\n    }\n  }\n  keys.forEach(key => {\n    let stateSlice = state[key];\n    let replacer;\n    let space;\n    let encrypt;\n    if (typeof key === 'object') {\n      let name = Object.keys(key)[0];\n      stateSlice = state[name];\n      if (typeof stateSlice !== 'undefined' && key[name]) {\n        // use serialize function if specified.\n        if (key[name].serialize) {\n          stateSlice = key[name].serialize(stateSlice);\n        } else {\n          // if serialize function is not specified filter on fields if an array has been provided.\n          let filter;\n          if (key[name].reduce) {\n            filter = key[name];\n          } else if (key[name].filter) {\n            filter = key[name].filter;\n          }\n          if (filter) {\n            stateSlice = createStateSlice(stateSlice, filter);\n          }\n          // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n          if (key[name].encrypt && key[name].decrypt) {\n            if (typeof key[name].encrypt === 'function') {\n              encrypt = key[name].encrypt;\n            }\n          } else if (key[name].encrypt || key[name].decrypt) {\n            // If one of those is not present, then let know that one is missing\n            console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);\n          }\n        }\n        /*\n        Replacer and space arguments to pass to JSON.stringify.\n        If these fields don't exist, undefined will be passed.\n        */\n        replacer = key[name].replacer;\n        space = key[name].space;\n      }\n      key = name;\n    }\n    if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n      try {\n        if (encrypt) {\n          // ensure that a string message is passed\n          stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n        }\n        storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n      } catch (e) {\n        console.warn('Unable to save state to localStorage:', e);\n      }\n    } else if (typeof stateSlice === 'undefined' && removeOnUndefined && storage !== undefined) {\n      try {\n        storage.removeItem(storageKeySerializer(key));\n      } catch (e) {\n        console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);\n      }\n    }\n  });\n};\n// Default merge strategy is a full deep merge.\nconst defaultMergeReducer = (state, rehydratedState, action) => {\n  if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n    const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;\n    const options = {\n      arrayMerge: overwriteMerge\n    };\n    state = deepmerge(state, rehydratedState, options);\n  }\n  return state;\n};\nconst localStorageSync = config => reducer => {\n  if (config.storage === undefined && !config.checkStorageAvailability || config.checkStorageAvailability && checkIsBrowserEnv()) {\n    config.storage = localStorage || window.localStorage;\n  }\n  if (config.storageKeySerializer === undefined) {\n    config.storageKeySerializer = key => key;\n  }\n  if (config.restoreDates === undefined) {\n    config.restoreDates = true;\n  }\n  // Use default merge reducer.\n  let mergeReducer = config.mergeReducer;\n  if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n    mergeReducer = defaultMergeReducer;\n  }\n  const stateKeys = validateStateKeys(config.keys);\n  const rehydratedState = config.rehydrate ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates) : undefined;\n  return function (state, action) {\n    let nextState;\n    // If state arrives undefined, we need to let it through the supplied reducer\n    // in order to get a complete state as defined by user\n    if (action.type === INIT_ACTION && !state) {\n      nextState = reducer(state, action);\n    } else {\n      nextState = {\n        ...state\n      };\n    }\n    // Merge the store state with the rehydrated state using\n    // either a user-defined reducer or the default.\n    nextState = mergeReducer(nextState, rehydratedState, action);\n    nextState = reducer(nextState, action);\n    if (action.type !== INIT_ACTION) {\n      syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n    }\n    return nextState;\n  };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { dateReviver, defaultMergeReducer, localStorageSync, rehydrateApplicationState, syncStateUpdate };","map":{"version":3,"names":["deepmerge","INIT_ACTION","UPDATE_ACTION","detectDate","dateReviver","_key","value","test","Date","dummyReviver","checkIsBrowserEnv","window","validateStateKeys","keys","map","key","attr","Object","TypeError","rehydrateApplicationState","storage","storageKeySerializer","restoreDates","reduce","acc","curr","reviver","deserialize","decrypt","encrypt","console","error","undefined","stateSlice","getItem","isObjectRegex","RegExp","raw","charAt","JSON","parse","assign","createStateSlice","existingSlice","filter","memo","prototype","hasOwnProperty","call","element","syncStateUpdate","state","removeOnUndefined","syncCondition","e","forEach","replacer","space","name","serialize","stringify","setItem","warn","removeItem","defaultMergeReducer","rehydratedState","action","type","overwriteMerge","destinationArray","sourceArray","options","arrayMerge","localStorageSync","config","reducer","checkStorageAvailability","localStorage","mergeReducer","stateKeys","rehydrate","nextState"],"sources":["/Users/tiendung1998/Documents/Angular/document-management/node_modules/ngrx-store-localstorage/fesm2022/ngrx-store-localstorage.mjs"],"sourcesContent":["import deepmerge from 'deepmerge';\n\n// Cannot import from the @ngrx/store package due to a module resolution issue.\n// See Issue #206.\nconst INIT_ACTION = '@ngrx/store/init';\nconst UPDATE_ACTION = '@ngrx/store/update-reducers';\nconst detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n// correctly parse dates from local storage\nconst dateReviver = (_key, value) => {\n    if (typeof value === 'string' && detectDate.test(value)) {\n        return new Date(value);\n    }\n    return value;\n};\nconst dummyReviver = (_key, value) => value;\nconst checkIsBrowserEnv = () => {\n    return typeof window !== 'undefined';\n};\nconst validateStateKeys = (keys) => {\n    return keys.map((key) => {\n        let attr = key;\n        if (typeof key === 'object') {\n            attr = Object.keys(key)[0];\n        }\n        if (typeof attr !== 'string') {\n            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);\n        }\n        return key;\n    });\n};\nconst rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {\n    return keys.reduce((acc, curr) => {\n        let key = curr;\n        let reviver = restoreDates ? dateReviver : dummyReviver;\n        let deserialize;\n        let decrypt;\n        if (typeof key === 'object') {\n            key = Object.keys(key)[0];\n            // use the custom reviver function\n            if (typeof curr[key] === 'function') {\n                reviver = curr[key];\n            }\n            else {\n                // use custom reviver function if available\n                if (curr[key].reviver) {\n                    reviver = curr[key].reviver;\n                }\n                // use custom serialize function if available\n                if (curr[key].deserialize) {\n                    deserialize = curr[key].deserialize;\n                }\n            }\n            // Ensure that encrypt and decrypt functions are both present\n            if (curr[key].encrypt && curr[key].decrypt) {\n                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n                    decrypt = curr[key].decrypt;\n                }\n                else {\n                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);\n                }\n            }\n            else if (curr[key].encrypt || curr[key].decrypt) {\n                // Let know that one of the encryption functions is not provided\n                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);\n            }\n        }\n        if (storage !== undefined) {\n            let stateSlice = storage.getItem(storageKeySerializer(key));\n            if (stateSlice) {\n                // Use provided decrypt function\n                if (decrypt) {\n                    stateSlice = decrypt(stateSlice);\n                }\n                const isObjectRegex = new RegExp('{|\\\\[');\n                let raw = stateSlice;\n                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n                    raw = JSON.parse(stateSlice, reviver);\n                }\n                return Object.assign({}, acc, {\n                    [key]: deserialize ? deserialize(raw) : raw,\n                });\n            }\n        }\n        return acc;\n    }, {});\n};\n// Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\nfunction createStateSlice(existingSlice, filter) {\n    return filter.reduce((memo, attr) => {\n        if (typeof attr === 'string' || typeof attr === 'number') {\n            const value = existingSlice?.[attr];\n            if (value !== undefined) {\n                memo[attr] = value;\n            }\n        }\n        else {\n            for (const key in attr) {\n                if (Object.prototype.hasOwnProperty.call(attr, key)) {\n                    const element = attr[key];\n                    memo[key] = createStateSlice(existingSlice[key], element);\n                }\n            }\n        }\n        return memo;\n    }, {});\n}\nconst syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {\n    if (syncCondition) {\n        try {\n            if (syncCondition(state) !== true) {\n                return;\n            }\n        }\n        catch (e) {\n            // Treat TypeError as do not sync\n            if (e instanceof TypeError) {\n                return;\n            }\n            throw e;\n        }\n    }\n    keys.forEach((key) => {\n        let stateSlice = state[key];\n        let replacer;\n        let space;\n        let encrypt;\n        if (typeof key === 'object') {\n            let name = Object.keys(key)[0];\n            stateSlice = state[name];\n            if (typeof stateSlice !== 'undefined' && key[name]) {\n                // use serialize function if specified.\n                if (key[name].serialize) {\n                    stateSlice = key[name].serialize(stateSlice);\n                }\n                else {\n                    // if serialize function is not specified filter on fields if an array has been provided.\n                    let filter;\n                    if (key[name].reduce) {\n                        filter = key[name];\n                    }\n                    else if (key[name].filter) {\n                        filter = key[name].filter;\n                    }\n                    if (filter) {\n                        stateSlice = createStateSlice(stateSlice, filter);\n                    }\n                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n                    if (key[name].encrypt && key[name].decrypt) {\n                        if (typeof key[name].encrypt === 'function') {\n                            encrypt = key[name].encrypt;\n                        }\n                    }\n                    else if (key[name].encrypt || key[name].decrypt) {\n                        // If one of those is not present, then let know that one is missing\n                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);\n                    }\n                }\n                /*\n          Replacer and space arguments to pass to JSON.stringify.\n          If these fields don't exist, undefined will be passed.\n        */\n                replacer = key[name].replacer;\n                space = key[name].space;\n            }\n            key = name;\n        }\n        if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n            try {\n                if (encrypt) {\n                    // ensure that a string message is passed\n                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n                }\n                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n            }\n            catch (e) {\n                console.warn('Unable to save state to localStorage:', e);\n            }\n        }\n        else if (typeof stateSlice === 'undefined' && removeOnUndefined && storage !== undefined) {\n            try {\n                storage.removeItem(storageKeySerializer(key));\n            }\n            catch (e) {\n                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);\n            }\n        }\n    });\n};\n// Default merge strategy is a full deep merge.\nconst defaultMergeReducer = (state, rehydratedState, action) => {\n    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;\n        const options = {\n            arrayMerge: overwriteMerge,\n        };\n        state = deepmerge(state, rehydratedState, options);\n    }\n    return state;\n};\nconst localStorageSync = (config) => (reducer) => {\n    if ((config.storage === undefined && !config.checkStorageAvailability) ||\n        (config.checkStorageAvailability && checkIsBrowserEnv())) {\n        config.storage = localStorage || window.localStorage;\n    }\n    if (config.storageKeySerializer === undefined) {\n        config.storageKeySerializer = (key) => key;\n    }\n    if (config.restoreDates === undefined) {\n        config.restoreDates = true;\n    }\n    // Use default merge reducer.\n    let mergeReducer = config.mergeReducer;\n    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n        mergeReducer = defaultMergeReducer;\n    }\n    const stateKeys = validateStateKeys(config.keys);\n    const rehydratedState = config.rehydrate\n        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)\n        : undefined;\n    return function (state, action) {\n        let nextState;\n        // If state arrives undefined, we need to let it through the supplied reducer\n        // in order to get a complete state as defined by user\n        if (action.type === INIT_ACTION && !state) {\n            nextState = reducer(state, action);\n        }\n        else {\n            nextState = { ...state };\n        }\n        // Merge the store state with the rehydrated state using\n        // either a user-defined reducer or the default.\n        nextState = mergeReducer(nextState, rehydratedState, action);\n        nextState = reducer(nextState, action);\n        if (action.type !== INIT_ACTION) {\n            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n        }\n        return nextState;\n    };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { dateReviver, defaultMergeReducer, localStorageSync, rehydrateApplicationState, syncStateUpdate };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}